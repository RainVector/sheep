1.【问题描述】
某些整数能分解成若干个连续整数的和的形式，例如
    15 = 1 + 2＋3＋4＋5　
    15 = 4 + 5 + 6
    15 = 7 + 8
某些整数不能分解为连续整数的和，例如：16
输入：一个整数N（N <= 10000）
输出：整数N对应的所有分解组合，按照每个分解中的最小整数从小到大输出，每个分解占一行，每个数字之间有一个空格（每行最后保留一个空格）；如果没有任何分解组合，则输出NONE。
解题思路：
根据题目，任何可以进行分解的整数，必然满足(m+n)(n-m+1)/2的形式，可以暴力尝试所有m和n组合，如果满足则输出，否则输出None。
2.【问题描述】
小岛面积
       1 1 1 1 1 1
       1 1 0 0 0 1
       1 0 0 0 1 0
       1 1 0 1 1 1
       0 1 0 1 0 0
       1 1 1 1 1 1
上面矩阵的中的1代表海岸线，0代表小岛。求小岛面积（即被1中包围的0的个数）。注意：仅求这样的0，该0所在行中被两个1包围，该0所在列中被两个1包围。
输入：
第一行输入一个整数N，表示输入方阵的维数
  	输入一个N维方阵
输出：
小岛面积
样例输入：
6
1 1 1 1 1 1
1 1 0 0 0 1
1 0 0 0 1 0
1 1 0 1 1 1
0 1 0 1 0 0
1 1 1 1 1 1
样例输出：
8
解题思路：
理解题目本身意思，可以发现对于矩阵中的0是否属于内陆，取决于该0所处的行和列上，如果0满足，如下条件则O为内陆，否则不是。
> 0所在的行，0的左边和右边必须有1
> 0所在的列，0的上面和下面必须有1
所以，解题思路就是，遍历所有的行和列，记录改行或列，最左面和最右面（或者最上面和最下面）1的坐标，然后当遇到0，判断是否处于记录的值的中间，是，则是内陆，面积加1，否则不加。

3.【问题描述】
统计关键字出现位置
输入：
一行标准c语言代码（字符个数小于300），统计出该字符串中关键字的if，while，for所在的位置，按照关键字出现的顺序依次输出。注意双引号内的不需要统计。
输入：一行标准c语言代码，字符个数小于300
输出：
关键字if，while，for对应的位置，按照关键字出现的顺序依次输出。输出格式为：关键字，后跟冒号，然后是出现的位置。扫描到关键字就输出，每个输出占一行。
样例输入：
#include <stdio.h> int main() {int i = 0; if(i == 0) printf("YES"); return 0;}
#include <stdio.h> int main() {int ifwhile = 0; int forif = 1;char if_for_while = 'a';char *str = "while"; while(ifwhile == 0) {ifwhile = 1;forif = 0;} if(forif == 0) {if_for_while = 'b';} if(ifwhile == 1) {if_for_while = 'c';} return 0;}
样例输出：
if:43
while:88
if:133
if:170
解题思路：
首先把输入字符串切分为一个个的单词，然后对每个单词进行匹配。注意c语言中的strtok函数，不能够返回位置（当分隔符连续时，比如+=,计算出前导的分割符有几个），所以不能满足本题的要求，必须自己写获取单词的函数（反正也不复杂啦）。因为考虑到引号的问题，我们的解决方案是首先对输入字符串进行预处理，将“”内的每个字符都替换为#，然后再进行单词分割（切词），最后进行匹配。具体步骤：
> 输入源码字符串预处理，将””内的每个字符替换为#
> 一次获取源码中的单词，看是否为查找的关键词，如果是则输出


